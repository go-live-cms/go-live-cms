// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: images.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createImage = `-- name: CreateImage :one
INSERT INTO images (
    name,
    description,
    alt,
    image_path,
    user_id
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, name, description, alt, image_path, user_id, created_at, changed_at
`

type CreateImageParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Alt         string `json:"alt"`
	ImagePath   string `json:"image_path"`
	UserID      int64  `json:"user_id"`
}

func (q *Queries) CreateImage(ctx context.Context, arg CreateImageParams) (Image, error) {
	row := q.db.QueryRowContext(ctx, createImage,
		arg.Name,
		arg.Description,
		arg.Alt,
		arg.ImagePath,
		arg.UserID,
	)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Alt,
		&i.ImagePath,
		&i.UserID,
		&i.CreatedAt,
		&i.ChangedAt,
	)
	return i, err
}

const createPostImage = `-- name: CreatePostImage :one
INSERT INTO post_images (
    post_id,
    image_id,
    "order"
) VALUES (
    $1, $2, $3
) RETURNING post_id, image_id, "order"
`

type CreatePostImageParams struct {
	PostID  int64 `json:"post_id"`
	ImageID int64 `json:"image_id"`
	Order   int32 `json:"order"`
}

func (q *Queries) CreatePostImage(ctx context.Context, arg CreatePostImageParams) (PostImage, error) {
	row := q.db.QueryRowContext(ctx, createPostImage, arg.PostID, arg.ImageID, arg.Order)
	var i PostImage
	err := row.Scan(&i.PostID, &i.ImageID, &i.Order)
	return i, err
}

const deleteImage = `-- name: DeleteImage :exec
DELETE FROM images
WHERE id = $1
`

func (q *Queries) DeleteImage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteImage, id)
	return err
}

const deleteImagePosts = `-- name: DeleteImagePosts :exec
DELETE FROM post_images
WHERE image_id = $1
`

func (q *Queries) DeleteImagePosts(ctx context.Context, imageID int64) error {
	_, err := q.db.ExecContext(ctx, deleteImagePosts, imageID)
	return err
}

const deleteImagesByUserID = `-- name: DeleteImagesByUserID :exec
DELETE FROM images
WHERE user_id = $1
`

func (q *Queries) DeleteImagesByUserID(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteImagesByUserID, userID)
	return err
}

const deletePostImage = `-- name: DeletePostImage :exec
DELETE FROM post_images
WHERE post_id = $1 AND image_id = $2
`

type DeletePostImageParams struct {
	PostID  int64 `json:"post_id"`
	ImageID int64 `json:"image_id"`
}

func (q *Queries) DeletePostImage(ctx context.Context, arg DeletePostImageParams) error {
	_, err := q.db.ExecContext(ctx, deletePostImage, arg.PostID, arg.ImageID)
	return err
}

const deletePostImages = `-- name: DeletePostImages :exec
DELETE FROM post_images
WHERE post_id = $1
`

func (q *Queries) DeletePostImages(ctx context.Context, postID int64) error {
	_, err := q.db.ExecContext(ctx, deletePostImages, postID)
	return err
}

const getImage = `-- name: GetImage :one
SELECT id, name, description, alt, image_path, user_id, created_at, changed_at FROM images
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetImage(ctx context.Context, id int64) (Image, error) {
	row := q.db.QueryRowContext(ctx, getImage, id)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Alt,
		&i.ImagePath,
		&i.UserID,
		&i.CreatedAt,
		&i.ChangedAt,
	)
	return i, err
}

const getImagePostCount = `-- name: GetImagePostCount :one
SELECT COUNT(*) FROM post_images
WHERE image_id = $1
`

func (q *Queries) GetImagePostCount(ctx context.Context, imageID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getImagePostCount, imageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getImagesByPost = `-- name: GetImagesByPost :many
SELECT i.id, i.name, i.description, i.alt, i.image_path, i.user_id, i.created_at, i.changed_at FROM images i
JOIN post_images pi ON i.id = pi.image_id
WHERE pi.post_id = $1
ORDER BY pi."order", i.created_at
`

func (q *Queries) GetImagesByPost(ctx context.Context, postID int64) ([]Image, error) {
	rows, err := q.db.QueryContext(ctx, getImagesByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.ImagePath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImagesByUser = `-- name: GetImagesByUser :many
SELECT id, name, description, alt, image_path, user_id, created_at, changed_at FROM images
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetImagesByUserParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetImagesByUser(ctx context.Context, arg GetImagesByUserParams) ([]Image, error) {
	rows, err := q.db.QueryContext(ctx, getImagesByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.ImagePath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularImages = `-- name: GetPopularImages :many
SELECT 
    i.id, i.name, i.description, i.alt, i.image_path, i.user_id, i.created_at, i.changed_at,
    COUNT(pi.post_id) as post_count
FROM images i
JOIN post_images pi ON i.id = pi.image_id
GROUP BY i.id, i.name, i.description, i.alt, i.image_path, i.user_id, i.created_at, i.changed_at
HAVING COUNT(pi.post_id) > 0
ORDER BY COUNT(pi.post_id) DESC
LIMIT $1
`

type GetPopularImagesRow struct {
	ID          int64     `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Alt         string    `json:"alt"`
	ImagePath   string    `json:"image_path"`
	UserID      int64     `json:"user_id"`
	CreatedAt   time.Time `json:"created_at"`
	ChangedAt   time.Time `json:"changed_at"`
	PostCount   int64     `json:"post_count"`
}

func (q *Queries) GetPopularImages(ctx context.Context, limit int32) ([]GetPopularImagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPopularImages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularImagesRow{}
	for rows.Next() {
		var i GetPopularImagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.ImagePath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.PostCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostImageCount = `-- name: GetPostImageCount :one
SELECT COUNT(*) FROM post_images
WHERE post_id = $1
`

func (q *Queries) GetPostImageCount(ctx context.Context, postID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPostImageCount, postID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPostWithImages = `-- name: GetPostWithImages :one
SELECT 
    p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', i.id,
                'name', i.name,
                'description', i.description,
                'alt', i.alt,
                'image_path', i.image_path,
                'user_id', i.user_id,
                'created_at', i.created_at,
                'changed_at', i.changed_at,
                'order', pi."order"
            ) ORDER BY pi."order", i.created_at
        ) FILTER (WHERE i.id IS NOT NULL),
        '[]'::json
    ) as images
FROM posts p
LEFT JOIN post_images pi ON p.id = pi.post_id
LEFT JOIN images i ON pi.image_id = i.id
WHERE p.id = $1
GROUP BY p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at
`

type GetPostWithImagesRow struct {
	ID          int64       `json:"id"`
	Title       string      `json:"title"`
	Description string      `json:"description"`
	Content     string      `json:"content"`
	UserID      int64       `json:"user_id"`
	Username    string      `json:"username"`
	Url         string      `json:"url"`
	CreatedAt   time.Time   `json:"created_at"`
	ChangedAt   time.Time   `json:"changed_at"`
	Images      interface{} `json:"images"`
}

func (q *Queries) GetPostWithImages(ctx context.Context, id int64) (GetPostWithImagesRow, error) {
	row := q.db.QueryRowContext(ctx, getPostWithImages, id)
	var i GetPostWithImagesRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.UserID,
		&i.Username,
		&i.Url,
		&i.CreatedAt,
		&i.ChangedAt,
		&i.Images,
	)
	return i, err
}

const getPostsByUserWithImages = `-- name: GetPostsByUserWithImages :many
SELECT 
    p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', i.id,
                'name', i.name,
                'description', i.description,
                'alt', i.alt,
                'image_path', i.image_path,
                'user_id', i.user_id,
                'created_at', i.created_at,
                'changed_at', i.changed_at,
                'order', pi."order"
            ) ORDER BY pi."order", i.created_at
        ) FILTER (WHERE i.id IS NOT NULL),
        '[]'::json
    ) as images
FROM posts p
LEFT JOIN post_images pi ON p.id = pi.post_id
LEFT JOIN images i ON pi.image_id = i.id
WHERE p.user_id = $1
GROUP BY p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at
ORDER BY p.created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserWithImagesParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPostsByUserWithImagesRow struct {
	ID          int64       `json:"id"`
	Title       string      `json:"title"`
	Description string      `json:"description"`
	Content     string      `json:"content"`
	UserID      int64       `json:"user_id"`
	Username    string      `json:"username"`
	Url         string      `json:"url"`
	CreatedAt   time.Time   `json:"created_at"`
	ChangedAt   time.Time   `json:"changed_at"`
	Images      interface{} `json:"images"`
}

func (q *Queries) GetPostsByUserWithImages(ctx context.Context, arg GetPostsByUserWithImagesParams) ([]GetPostsByUserWithImagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserWithImages, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostsByUserWithImagesRow{}
	for rows.Next() {
		var i GetPostsByUserWithImagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.UserID,
			&i.Username,
			&i.Url,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserImageCount = `-- name: GetUserImageCount :one
SELECT COUNT(*) FROM images
WHERE user_id = $1
`

func (q *Queries) GetUserImageCount(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserImageCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listImages = `-- name: ListImages :many
SELECT id, name, description, alt, image_path, user_id, created_at, changed_at FROM images
ORDER BY created_at DESC
LIMIT $1
OFFSET $2
`

type ListImagesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListImages(ctx context.Context, arg ListImagesParams) ([]Image, error) {
	rows, err := q.db.QueryContext(ctx, listImages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.ImagePath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImagesWithPostCount = `-- name: ListImagesWithPostCount :many
SELECT 
    i.id, i.name, i.description, i.alt, i.image_path, i.user_id, i.created_at, i.changed_at,
    COUNT(pi.post_id) as post_count
FROM images i
LEFT JOIN post_images pi ON i.id = pi.image_id
GROUP BY i.id, i.name, i.description, i.alt, i.image_path, i.user_id, i.created_at, i.changed_at
ORDER BY i.created_at DESC
LIMIT $1
OFFSET $2
`

type ListImagesWithPostCountParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListImagesWithPostCountRow struct {
	ID          int64     `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Alt         string    `json:"alt"`
	ImagePath   string    `json:"image_path"`
	UserID      int64     `json:"user_id"`
	CreatedAt   time.Time `json:"created_at"`
	ChangedAt   time.Time `json:"changed_at"`
	PostCount   int64     `json:"post_count"`
}

func (q *Queries) ListImagesWithPostCount(ctx context.Context, arg ListImagesWithPostCountParams) ([]ListImagesWithPostCountRow, error) {
	rows, err := q.db.QueryContext(ctx, listImagesWithPostCount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListImagesWithPostCountRow{}
	for rows.Next() {
		var i ListImagesWithPostCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.ImagePath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.PostCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsWithImages = `-- name: ListPostsWithImages :many
SELECT 
    p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', i.id,
                'name', i.name,
                'description', i.description,
                'alt', i.alt,
                'image_path', i.image_path,
                'user_id', i.user_id,
                'created_at', i.created_at,
                'changed_at', i.changed_at,
                'order', pi."order"
            ) ORDER BY pi."order", i.created_at
        ) FILTER (WHERE i.id IS NOT NULL),
        '[]'::json
    ) as images
FROM posts p
LEFT JOIN post_images pi ON p.id = pi.post_id
LEFT JOIN images i ON pi.image_id = i.id
GROUP BY p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at
ORDER BY p.created_at DESC
LIMIT $1
OFFSET $2
`

type ListPostsWithImagesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPostsWithImagesRow struct {
	ID          int64       `json:"id"`
	Title       string      `json:"title"`
	Description string      `json:"description"`
	Content     string      `json:"content"`
	UserID      int64       `json:"user_id"`
	Username    string      `json:"username"`
	Url         string      `json:"url"`
	CreatedAt   time.Time   `json:"created_at"`
	ChangedAt   time.Time   `json:"changed_at"`
	Images      interface{} `json:"images"`
}

func (q *Queries) ListPostsWithImages(ctx context.Context, arg ListPostsWithImagesParams) ([]ListPostsWithImagesRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsWithImages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostsWithImagesRow{}
	for rows.Next() {
		var i ListPostsWithImagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.UserID,
			&i.Username,
			&i.Url,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchImagesByName = `-- name: SearchImagesByName :many
SELECT id, name, description, alt, image_path, user_id, created_at, changed_at FROM images
WHERE name ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type SearchImagesByNameParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchImagesByName(ctx context.Context, arg SearchImagesByNameParams) ([]Image, error) {
	rows, err := q.db.QueryContext(ctx, searchImagesByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.ImagePath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transferImagesToUser = `-- name: TransferImagesToUser :exec
UPDATE images 
SET user_id = $2
WHERE user_id = $1
`

type TransferImagesToUserParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

func (q *Queries) TransferImagesToUser(ctx context.Context, arg TransferImagesToUserParams) error {
	_, err := q.db.ExecContext(ctx, transferImagesToUser, arg.UserID, arg.UserID_2)
	return err
}

const updateImage = `-- name: UpdateImage :one
UPDATE images 
SET 
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    alt = COALESCE($4, alt),
    image_path = COALESCE($5, image_path),
    changed_at = now()
WHERE id = $1
RETURNING id, name, description, alt, image_path, user_id, created_at, changed_at
`

type UpdateImageParams struct {
	ID          int64  `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Alt         string `json:"alt"`
	ImagePath   string `json:"image_path"`
}

func (q *Queries) UpdateImage(ctx context.Context, arg UpdateImageParams) (Image, error) {
	row := q.db.QueryRowContext(ctx, updateImage,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Alt,
		arg.ImagePath,
	)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Alt,
		&i.ImagePath,
		&i.UserID,
		&i.CreatedAt,
		&i.ChangedAt,
	)
	return i, err
}
